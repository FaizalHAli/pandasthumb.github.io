---
layout: article
title: 'Lab Notes: The Alias Method for Sampling from Discrete Distributions'
date: '2012-08-03 01:45:02 -0700'
mt_id: 6565
blog_id: 2
post_id: 6565
basename: lab_notes_the_a
---
I am a computational evolutionary geneticist, and in my research I develop software to analyze genetic data and study evolutionary questions.  As part of my research, I work with a lot of simulation programs to generate evolutionary datasets.  My most widely used program is <a href="http://scit.us/projects/dawg/">Dawg</a>, and I am currently putting the finishing touches on a new version.

In simulating molecular sequences, you start by simulating the ancestral sequence at the root of a phylogenetic tree and then evolve that sequence upwards, making point mutations and indels as you go.  Depending on type of sequences being generated, the root would be a string of nucleotides, amino acids, or codons.  To simulate the root sequence, we draw its characters from a discrete, stochastic distribution.  For example, lets say that in your system the frequencies of A, C, G, and T are 26%, 23%, 24%, and 27%.  In order to create a root sequences of length <i>k</i>, you simply sample <i>k</i> nucleotides from this distribution, e.g. AAGTGCA or GATTACA.

Therefore, the key step in the simulation of the root sequence is sampling repeatedly from an arbitrary discrete distribution.  While I have been doing this for years, I recently went searching for doing it better and came across the following excellent article: <a href="http://www.keithschwarz.com/darts-dice-coins/">Darts, Dice, and Coins</a>, written by Keith Schwarz, a lecturer at Stanford.  In this article, he describes many different methods for sampling from a discrete distribution and analyzes their performance.  It turns out the best method is the Alias Method, first described in the 1970s and improved by <a href="http://web.eecs.utk.edu/~vose/Publications/random.pdf">M. Vose in 1991</a>.  I will describe it below, but before we get there, here are some alternatives.

Imagine that you want to sample from the following discrete distribution of nucleotides:

<img alt="vose-0.png" src="http://pandasthumb.org/archives/2012/08/02/vose-0.png" width="500" height="500" class="mt-image-none" style="" />

Let the heights of these bars be <i>h<sub>0</sub></i>, <i>h<sub>1</sub></i>, <i>h<sub>2</sub></i>, and <i>h<sub>3</sub></i>.  Since these heights correspond to the probability that a random base is A, C, G, or T, the total area of the histogram is 1.  Now to sample from this histogram, you can draw a uniform random number---call it <i>u</i>---between 0 and 1 and find which bar corresponds to that number.  If <i>u &lt; h<sub>0</sub></i>, you sample an A.  If <i>u &lt; h<sub>0</sub>+h<sub>1</sub></i>, you sample a C, etc.  This works, but is clearly inefficient since it requires you to search through the histogram from left to right every time you sample a nucleotide.  Imagine if you were sampling from 64 codons.

<!--more-->

A more efficient method is to sample a point uniformly in a box that contains all the bars:

<img alt="vose-1.png" src="http://pandasthumb.org/archives/2012/08/02/vose-1.png" width="500" height="500" class="mt-image-none" style="" />

The (<i>x</i>, <i>y</i>) coordinates of the sampled point are defined by uniform random numbers between [0, 4) and [0,3/8) respectively.  If this point lands in the white space, you reject it and try again.  This approach is more efficient because once you have chosen <i>x</i>, you only need to compare <i>y</i> against <i>h<sub>floor(x)</sub></i>.
However, the white space makes up one third of the space in this box, and thus on average you will have to sample 1.5 points for every sampled nucleotide.

With the Alias Method, we can bring this down to 1 point for every sampled nucleotide.  Start by constructing the following box, which has an area of 1.

<img alt="vose-2.png" src="http://pandasthumb.org/archives/2012/08/02/vose-2.png" width="500" height="500" class="mt-image-none" style="" />

Notice that the amount of white space within the box is equal to the amount of filled space outside it. Thus it is possible to cut the histogram into blocks and rearrange them such that the entire box is filled.

<img alt="vose-3.png" src="http://pandasthumb.org/archives/2012/08/02/vose-3.png" width="500" height="500" class="mt-image-none" style="" />

Thus every bar is defined by two regions, the lower, normal region, and the upper, "alias" region.  Now we can draw a point (<i>x</i>, <i>y</i>) uniformly inside this box; <i>x</i> determines which bar we look at, and <i>y</i> determines whether we return the normal or the alias value.  Since there is no white space, we only have to draw 1 point per sampled nucleotide.

<blockcode>
/*
 *  C++ code for sampling from an alias table
 */

uint32_t a[64]; //aliases
uint64_t h[64]; //bar heights
uint32_t get_codon() {
	uint64_t u = rand_uint64();
	uint32_t x = u&63;
	return (u < h[x]) ? x : a[x];
}
</blockcode>

Now the hard part comes in slicing and moving the blocks around.  That is where Vose's method come in.  Basically keep a list of bars above or below the top line of the box, called large and small.  Then pop an element off of both lists, and use the large element to fill in the small element.  If the large element is still above the line, put it back in the large list, otherwise put it in the small list.  Repeat until the box is filled.  The process looks a bit like this:

<img alt="vose.png" src="http://pandasthumb.org/archives/2012/08/02/vose.png" width="500" height="500" class="mt-image-none" style="" />

While Vose's method is typically implemented using arrays, (see <a href="http://www.keithschwarz.com/darts-dice-coins/">Darts, Dice, and Coins</a>), array manipulation can be expensive.  However, it is possible to implement Vose's method without using temporary arrays to hold large and small elements.  In the code below, I use indices to walk through the histogram linearly.  Only three indices are required: <i>g</i> for the current large bar, <i>m</i> for the current small bar, and <i>mm</i> for the next possible small bar. While <i>g</i> and <i>mm</i> keep track of the positions that we've examined and never decrease, <i>m</i> sometimes will jump backwards if a large bar has become small.  This is the code that Dawg 2.0 is currently using to construct an alias table for codon simulations, and is more efficient than previous solutions.

<blockcode>
/*
 *  Initialize alias table from discrete distribution, pp
 */

void create_alias_table(const double *pp) {
    // normalize pp and copy into buffer
    double f=0.0, p[64];
    for(int i=0;i<64;++i)
        f += pp[i];
    f = 64.0/f;
    for(int i=0;i<64;++i)
        p[i] = pp[i]*f;
    
    // find starting positions
    std::size_t g,m,mm;
    for(g=0; g<64 && p[g] <  1.0; ++g)
        /*noop*/;
    for(m=0; m<64 && p[m] >= 1.0; ++m)
        /*noop*/;
    mm = m+1;
    
    // build alias table until we run out of large or small bars
    while(g < 64 && m < 64) {
        // convert double to 64-bit integer, control for precision
        h[m] = (static_cast<uint64_t>(
                ceil(p[m]*9007199254740992.0)) << 11);
        a[m] = g;
        p[g] = (p[g]+p[m])-1.0;
        if(p[g] >= 1.0 || mm <= g) {
            for(m=mm;m<64 && p[m] >= 1.0; ++m)
                /*noop*/;
            mm = m+1;
        } else
            m = g;
        for(; g<64 && p[g] <  1.0; ++g)
            /*noop*/;
    }
    
    // any bars that remain have no alias 
    for(; g<64; ++g) {
        if(p[g] < 1.0)
            continue;
        h[g] = std::numeric_limits<boost::uint64_t>::max();
        a[g] = g;
    }
    if(m < 64) {
        q[m] = std::numeric_limits<boost::uint64_t>::max();
        a[m] = m;
        for(m=mm; m<64; ++m) {
            if(p[m] > 1.0)
                continue;
            h[m] = std::numeric_limits<boost::uint64_t>::max();
            a[m] = m;
        }
    }
}
</blockcode>

Note that if the values in pp were not immutable, then we would not need p.

<b>Note 2012/11/25:</b> updated to fix typos.

<b>Note 2013/05/03:</b> fixed typo.
